# -*- coding: utf-8 -*-
"""Untitled12.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PDKqHXXa7H1RCLaPAaBBOVuzJMHSV61H
"""

from google.colab import drive
drive.mount('/content/drive')

!tar -xvzf /content/drive/MyDrive/pqas_light.tar.gz -C /content/

# Commented out IPython magic to ensure Python compatibility.
# ====== 3. 进入目录（假设解压后文件夹叫 pqas_light） ======
# %cd /content/pqas_light

# ====== 4. 安装依赖 ======
# 如果有 requirements.txt
!pip install -r requirements.txt
# 如果没有 requirements.txt，但有 setup.py
!pip install -e .

!pip install numpy scipy matplotlib pandas seaborn
!pip install qiskit qiskit-nature

!sudo apt-get update -y
!sudo apt-get install python3.10 python3.10-dev python3.10-distutils -y
!sudo update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.10 2
!sudo update-alternatives --config python3

!pip install --upgrade pip setuptools wheel
!pip install "qiskit==0.45.0" "qiskit-nature==0.6.0"

# 安装 Python 3.10
!sudo apt-get update -y
!sudo apt-get install python3.10 python3.10-dev python3.10-distutils -y
!sudo update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.10 2
!sudo update-alternatives --config python3

# 重启 Colab Runtime (必须手动点 Runtime → Restart runtime)

# 然后在新的环境里：
!pip install --upgrade pip setuptools wheel
!pip install "qiskit==0.45.0" "qiskit-nature==0.6.0"

import os

# 可能的候选路径
candidates = [
    "/content/pqas_full_program_with_setup",
    "/content/drive/MyDrive/pqas_full_program_with_setup"
]

found = None
for path in candidates:
    if os.path.exists(path):
        found = path
        break

if found:
    print(f"✅ Found project folder at: {found}")
    os.chdir(found)
    # 列出 pqas/scripts 看看
    os.system("ls pqas/scripts")
else:
    print("❌ Could not find pqas_full_program_with_setup, please check your Drive or upload again.")

!python -m pqas.scripts.run_grid_real \
  --db results.sqlite \
  --mols H2 \
  --bases 6-31G \
  --optimizer COBYLA L-BFGS-B \
  --seeds 0 1 2 \
  --reps 2 \
  --bond_lengths 0.60 0.70 0.74 0.78 0.90 1.10 1.30 1.80

from google.colab import drive

# 挂载 Google Drive
drive.mount('/content/drive')

import pandas as pd

file_path = "/content/drive/MyDrive/codecarbon-master/leaderboard_fixed.csv"
df = pd.read_csv(file_path)
print(df.head())


import pandas as pd
df = pd.read_csv(file_path)
print(df.head())

# ==============================
# FLOPs-based Predictor Evaluation
# ==============================

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.ensemble import GradientBoostingRegressor
from sklearn.metrics import mean_absolute_percentage_error, r2_score

# 1. 读取数据
file_path = "/content/drive/MyDrive/codecarbon-master/leaderboard_fixed.csv"
df = pd.read_csv(file_path)

# 确保有 flops 和 emissions 列
print(df.columns)

# 2. 提取特征和标签
X = df[["flops"]].values
y = df["emissions"].values

# log scale（可选，看拟合效果）
X_log = np.log10(X + 1)

# 3. 划分训练/测试集
X_train, X_test, y_train, y_test = train_test_split(X_log, y, test_size=0.2, random_state=42)

# 4. 训练两个预测器
linear = LinearRegression().fit(X_train, y_train)
gbdt = GradientBoostingRegressor().fit(X_train, y_train)

# 5. 预测结果
y_pred_linear = linear.predict(X_test)
y_pred_gbdt = gbdt.predict(X_test)

# 6. 评估指标
print("===== Linear Regression =====")
print("MAPE:", mean_absolute_percentage_error(y_test, y_pred_linear))
print("R2:", r2_score(y_test, y_pred_linear))

print("===== GBDT =====")
print("MAPE:", mean_absolute_percentage_error(y_test, y_pred_gbdt))
print("R2:", r2_score(y_test, y_pred_gbdt))

# 7. 可视化：实际 vs 预测
plt.figure(figsize=(8,6))
plt.scatter(y_test, y_pred_linear, alpha=0.6, label="Linear Regression")
plt.scatter(y_test, y_pred_gbdt, alpha=0.6, label="GBDT")
plt.plot([y.min(), y.max()], [y.min(), y.max()], "k--", lw=2)
plt.xlabel("Actual Emissions")
plt.ylabel("Predicted Emissions")
plt.title("FLOPs-based Predictor: Actual vs Predicted")
plt.legend()
plt.show()

# 8. 可视化：误差分布
errors_linear = y_test - y_pred_linear
errors_gbdt = y_test - y_pred_gbdt

plt.figure(figsize=(8,6))
sns.histplot(errors_linear, kde=True, label="Linear", color="blue")
sns.histplot(errors_gbdt, kde=True, label="GBDT", color="orange")
plt.xlabel("Prediction Error (J)")
plt.title("Error Distribution of Predictors")
plt.legend()
plt.show()

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import OneHotEncoder
from sklearn.metrics import mean_absolute_error, mean_absolute_percentage_error, r2_score
from sklearn.linear_model import LinearRegression
from sklearn.ensemble import GradientBoostingRegressor
import matplotlib.pyplot as plt

# 1. 读取数据
file_path = "/content/drive/MyDrive/codecarbon-master/leaderboard_fixed.csv"
df = pd.read_csv(file_path)
print(df.shape)                       # 总条数
print(df["emissions"].notna().sum())  # 有效条数
print("总条数:", len(df))
print("有效条数 (emissions 非空):", df["emissions"].notna().sum())
print("缺失条数:", df["emissions"].isna().sum())
# ==========================
# 1. 导入依赖
# ==========================
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.metrics import mean_absolute_error, mean_absolute_percentage_error, r2_score
from sklearn.linear_model import LinearRegression
from sklearn.ensemble import GradientBoostingRegressor

# ==========================
# 2. 读取数据
# ==========================

print("总条数:", len(df))
print("有效条数:", df['emissions'].notna().sum())
print("缺失条数:", df['emissions'].isna().sum())
print(df.head())

# ==========================
# 3. 特征选择
# ==========================
# 数值特征：flops
# 分类特征：model, task, device, optimizer (如果有的话)
num_features = ["flops"]
cat_features = [col for col in ["model", "task", "device", "optimizer"] if col in df.columns]

X = df[num_features + cat_features]
y = df["emissions"]

# ==========================
# 4. 定义预处理 + 模型
# ==========================
preprocessor = ColumnTransformer(
    transformers=[
        ("num", "passthrough", num_features),
        ("cat", OneHotEncoder(handle_unknown="ignore"), cat_features)
    ]
)

models = {
    "Linear Regression": LinearRegression(),
    "GBDT": GradientBoostingRegressor(random_state=42)
}

results = {}

# ==========================
# 5. 训练 & 评估
# ==========================
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

for name, model in models.items():
    pipe = Pipeline(steps=[("pre", preprocessor), ("model", model)])
    pipe.fit(X_train, y_train)
    y_pred = pipe.predict(X_test)

    mae = mean_absolute_error(y_test, y_pred)
    mape = mean_absolute_percentage_error(y_test, y_pred) * 100
    r2 = r2_score(y_test, y_pred)

    results[name] = {"MAE": mae, "MAPE": mape, "R2": r2}

    # ===== 可视化：实际 vs 预测 =====
    plt.figure()
    plt.scatter(y_test, y_pred, label=name, alpha=0.7)
    plt.plot([y.min(), y.max()], [y.min(), y.max()], "k--", lw=2)
    plt.xlabel("Actual Emissions")
    plt.ylabel("Predicted Emissions")
    plt.title(f"Actual vs Predicted ({name})")
    plt.legend()
    plt.show()

    # ===== 可视化：误差分布 =====
    errors = y_pred - y_test
    plt.figure()
    sns.histplot(errors, kde=True, bins=10, label=name)
    plt.xlabel("Prediction Error (J)")
    plt.ylabel("Count")
    plt.title(f"Error Distribution ({name})")
    plt.legend()
    plt.show()

# ==========================
# 6. 输出指标
# ==========================
print("\n===== Summary =====")
for name, metrics in results.items():
    print(f"{name}: MAE={metrics['MAE']:.6f}, MAPE={metrics['MAPE']:.2f}%, R2={metrics['R2']:.4f}")